// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/arpb2/C-3PO/third_party/ent/classroom"
	"github.com/arpb2/C-3PO/third_party/ent/credential"
	"github.com/arpb2/C-3PO/third_party/ent/level"
	"github.com/arpb2/C-3PO/third_party/ent/schema"
	"github.com/arpb2/C-3PO/third_party/ent/user"
	"github.com/arpb2/C-3PO/third_party/ent/userlevel"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClassroom  = "Classroom"
	TypeCredential = "Credential"
	TypeLevel      = "Level"
	TypeUser       = "User"
	TypeUserLevel  = "UserLevel"
)

// ClassroomMutation represents an operation that mutate the Classrooms
// nodes in the graph.
type ClassroomMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	teacher         *uint
	clearedteacher  bool
	students        map[uint]struct{}
	removedstudents map[uint]struct{}
	level           *uint
	clearedlevel    bool
}

var _ ent.Mutation = (*ClassroomMutation)(nil)

// newClassroomMutation creates new mutation for $n.Name.
func newClassroomMutation(c config, op Op) *ClassroomMutation {
	return &ClassroomMutation{
		config:        c,
		op:            op,
		typ:           TypeClassroom,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Classroom creation.
func (m *ClassroomMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClassroomMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ClassroomMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ClassroomMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *ClassroomMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ClassroomMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ClassroomMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the updated_at field.
func (m *ClassroomMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTeacherID sets the teacher edge to User by id.
func (m *ClassroomMutation) SetTeacherID(id uint) {
	m.teacher = &id
}

// ClearTeacher clears the teacher edge to User.
func (m *ClassroomMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared returns if the edge teacher was cleared.
func (m *ClassroomMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the teacher id in the mutation.
func (m *ClassroomMutation) TeacherID() (id uint, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the teacher ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *ClassroomMutation) TeacherIDs() (ids []uint) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher reset all changes of the teacher edge.
func (m *ClassroomMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// AddStudentIDs adds the students edge to User by ids.
func (m *ClassroomMutation) AddStudentIDs(ids ...uint) {
	if m.students == nil {
		m.students = make(map[uint]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// RemoveStudentIDs removes the students edge to User by ids.
func (m *ClassroomMutation) RemoveStudentIDs(ids ...uint) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[uint]struct{})
	}
	for i := range ids {
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed ids of students.
func (m *ClassroomMutation) RemovedStudentsIDs() (ids []uint) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the students ids in the mutation.
func (m *ClassroomMutation) StudentsIDs() (ids []uint) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents reset all changes of the students edge.
func (m *ClassroomMutation) ResetStudents() {
	m.students = nil
	m.removedstudents = nil
}

// SetLevelID sets the level edge to Level by id.
func (m *ClassroomMutation) SetLevelID(id uint) {
	m.level = &id
}

// ClearLevel clears the level edge to Level.
func (m *ClassroomMutation) ClearLevel() {
	m.clearedlevel = true
}

// LevelCleared returns if the edge level was cleared.
func (m *ClassroomMutation) LevelCleared() bool {
	return m.clearedlevel
}

// LevelID returns the level id in the mutation.
func (m *ClassroomMutation) LevelID() (id uint, exists bool) {
	if m.level != nil {
		return *m.level, true
	}
	return
}

// LevelIDs returns the level ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LevelID instead. It exists only for internal usage by the builders.
func (m *ClassroomMutation) LevelIDs() (ids []uint) {
	if id := m.level; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLevel reset all changes of the level edge.
func (m *ClassroomMutation) ResetLevel() {
	m.level = nil
	m.clearedlevel = false
}

// Op returns the operation name.
func (m *ClassroomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Classroom).
func (m *ClassroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClassroomMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, classroom.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, classroom.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClassroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classroom.FieldCreatedAt:
		return m.CreatedAt()
	case classroom.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classroom.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case classroom.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Classroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClassroomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClassroomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClassroomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClassroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassroomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Classroom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClassroomMutation) ResetField(name string) error {
	switch name {
	case classroom.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case classroom.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Classroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClassroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.teacher != nil {
		edges = append(edges, classroom.EdgeTeacher)
	}
	if m.students != nil {
		edges = append(edges, classroom.EdgeStudents)
	}
	if m.level != nil {
		edges = append(edges, classroom.EdgeLevel)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClassroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classroom.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case classroom.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	case classroom.EdgeLevel:
		if id := m.level; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClassroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstudents != nil {
		edges = append(edges, classroom.EdgeStudents)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClassroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case classroom.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClassroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteacher {
		edges = append(edges, classroom.EdgeTeacher)
	}
	if m.clearedlevel {
		edges = append(edges, classroom.EdgeLevel)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClassroomMutation) EdgeCleared(name string) bool {
	switch name {
	case classroom.EdgeTeacher:
		return m.clearedteacher
	case classroom.EdgeLevel:
		return m.clearedlevel
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClassroomMutation) ClearEdge(name string) error {
	switch name {
	case classroom.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case classroom.EdgeLevel:
		m.ClearLevel()
		return nil
	}
	return fmt.Errorf("unknown Classroom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClassroomMutation) ResetEdge(name string) error {
	switch name {
	case classroom.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case classroom.EdgeStudents:
		m.ResetStudents()
		return nil
	case classroom.EdgeLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Classroom edge %s", name)
}

// CredentialMutation represents an operation that mutate the Credentials
// nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	salt          *[]byte
	password_hash *[]byte
	clearedFields map[string]struct{}
	holder        *uint
	clearedholder bool
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// newCredentialMutation creates new mutation for $n.Name.
func newCredentialMutation(c config, op Op) *CredentialMutation {
	return &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSalt sets the salt field.
func (m *CredentialMutation) SetSalt(b []byte) {
	m.salt = &b
}

// Salt returns the salt value in the mutation.
func (m *CredentialMutation) Salt() (r []byte, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalt reset all changes of the salt field.
func (m *CredentialMutation) ResetSalt() {
	m.salt = nil
}

// SetPasswordHash sets the password_hash field.
func (m *CredentialMutation) SetPasswordHash(b []byte) {
	m.password_hash = &b
}

// PasswordHash returns the password_hash value in the mutation.
func (m *CredentialMutation) PasswordHash() (r []byte, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// ResetPasswordHash reset all changes of the password_hash field.
func (m *CredentialMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetHolderID sets the holder edge to User by id.
func (m *CredentialMutation) SetHolderID(id uint) {
	m.holder = &id
}

// ClearHolder clears the holder edge to User.
func (m *CredentialMutation) ClearHolder() {
	m.clearedholder = true
}

// HolderCleared returns if the edge holder was cleared.
func (m *CredentialMutation) HolderCleared() bool {
	return m.clearedholder
}

// HolderID returns the holder id in the mutation.
func (m *CredentialMutation) HolderID() (id uint, exists bool) {
	if m.holder != nil {
		return *m.holder, true
	}
	return
}

// HolderIDs returns the holder ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HolderID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) HolderIDs() (ids []uint) {
	if id := m.holder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHolder reset all changes of the holder edge.
func (m *CredentialMutation) ResetHolder() {
	m.holder = nil
	m.clearedholder = false
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.salt != nil {
		fields = append(fields, credential.FieldSalt)
	}
	if m.password_hash != nil {
		fields = append(fields, credential.FieldPasswordHash)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldSalt:
		return m.Salt()
	case credential.FieldPasswordHash:
		return m.PasswordHash()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldSalt:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case credential.FieldPasswordHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CredentialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldSalt:
		m.ResetSalt()
		return nil
	case credential.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.holder != nil {
		edges = append(edges, credential.EdgeHolder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeHolder:
		if id := m.holder; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedholder {
		edges = append(edges, credential.EdgeHolder)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeHolder:
		return m.clearedholder
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeHolder:
		m.ClearHolder()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeHolder:
		m.ResetHolder()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// LevelMutation represents an operation that mutate the Levels
// nodes in the graph.
type LevelMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	definition    **schema.LevelDefinition
	clearedFields map[string]struct{}
}

var _ ent.Mutation = (*LevelMutation)(nil)

// newLevelMutation creates new mutation for $n.Name.
func newLevelMutation(c config, op Op) *LevelMutation {
	return &LevelMutation{
		config:        c,
		op:            op,
		typ:           TypeLevel,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Level creation.
func (m *LevelMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LevelMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *LevelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *LevelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *LevelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *LevelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *LevelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the updated_at field.
func (m *LevelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *LevelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *LevelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *LevelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *LevelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *LevelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// ResetDescription reset all changes of the description field.
func (m *LevelMutation) ResetDescription() {
	m.description = nil
}

// SetDefinition sets the definition field.
func (m *LevelMutation) SetDefinition(sd *schema.LevelDefinition) {
	m.definition = &sd
}

// Definition returns the definition value in the mutation.
func (m *LevelMutation) Definition() (r *schema.LevelDefinition, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefinition reset all changes of the definition field.
func (m *LevelMutation) ResetDefinition() {
	m.definition = nil
}

// Op returns the operation name.
func (m *LevelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Level).
func (m *LevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LevelMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, level.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, level.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, level.FieldName)
	}
	if m.description != nil {
		fields = append(fields, level.FieldDescription)
	}
	if m.definition != nil {
		fields = append(fields, level.FieldDefinition)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case level.FieldCreatedAt:
		return m.CreatedAt()
	case level.FieldUpdatedAt:
		return m.UpdatedAt()
	case level.FieldName:
		return m.Name()
	case level.FieldDescription:
		return m.Description()
	case level.FieldDefinition:
		return m.Definition()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case level.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case level.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case level.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case level.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case level.FieldDefinition:
		v, ok := value.(*schema.LevelDefinition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinition(v)
		return nil
	}
	return fmt.Errorf("unknown Level field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Level numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Level nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LevelMutation) ResetField(name string) error {
	switch name {
	case level.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case level.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case level.FieldName:
		m.ResetName()
		return nil
	case level.FieldDescription:
		m.ResetDescription()
		return nil
	case level.FieldDefinition:
		m.ResetDefinition()
		return nil
	}
	return fmt.Errorf("unknown Level field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LevelMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LevelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Level unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LevelMutation) ResetEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Level edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	_type              *user.Type
	email              *string
	name               *string
	surname            *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	credentials        *int
	clearedcredentials bool
}

var _ ent.Mutation = (*UserMutation)(nil)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op) *UserMutation {
	return &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on User creation.
func (m *UserMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *UserMutation) SetType(u user.Type) {
	m._type = &u
}

// GetType returns the type value in the mutation.
func (m *UserMutation) GetType() (r user.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the type field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmail reset all changes of the email field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetSurname sets the surname field.
func (m *UserMutation) SetSurname(s string) {
	m.surname = &s
}

// Surname returns the surname value in the mutation.
func (m *UserMutation) Surname() (r string, exists bool) {
	v := m.surname
	if v == nil {
		return
	}
	return *v, true
}

// ResetSurname reset all changes of the surname field.
func (m *UserMutation) ResetSurname() {
	m.surname = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the updated_at field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCredentialsID sets the credentials edge to Credential by id.
func (m *UserMutation) SetCredentialsID(id int) {
	m.credentials = &id
}

// ClearCredentials clears the credentials edge to Credential.
func (m *UserMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared returns if the edge credentials was cleared.
func (m *UserMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// CredentialsID returns the credentials id in the mutation.
func (m *UserMutation) CredentialsID() (id int, exists bool) {
	if m.credentials != nil {
		return *m.credentials, true
	}
	return
}

// CredentialsIDs returns the credentials ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CredentialsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CredentialsIDs() (ids []int) {
	if id := m.credentials; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCredentials reset all changes of the credentials edge.
func (m *UserMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.surname != nil {
		fields = append(fields, user.FieldSurname)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldType:
		return m.GetType()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldSurname:
		return m.Surname()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldType:
		v, ok := value.(user.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurname(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSurname:
		m.ResetSurname()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.credentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCredentials:
		if id := m.credentials; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcredentials {
		edges = append(edges, user.EdgeCredentials)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCredentials:
		return m.clearedcredentials
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCredentials:
		m.ClearCredentials()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCredentials:
		m.ResetCredentials()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserLevelMutation represents an operation that mutate the UserLevels
// nodes in the graph.
type UserLevelMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	code             *string
	workspace        *string
	clearedFields    map[string]struct{}
	developer        *uint
	cleareddeveloper bool
	level            *uint
	clearedlevel     bool
}

var _ ent.Mutation = (*UserLevelMutation)(nil)

// newUserLevelMutation creates new mutation for $n.Name.
func newUserLevelMutation(c config, op Op) *UserLevelMutation {
	return &UserLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLevel,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserLevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *UserLevelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserLevelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *UserLevelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserLevelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserLevelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the updated_at field.
func (m *UserLevelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the code field.
func (m *UserLevelMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *UserLevelMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// ResetCode reset all changes of the code field.
func (m *UserLevelMutation) ResetCode() {
	m.code = nil
}

// SetWorkspace sets the workspace field.
func (m *UserLevelMutation) SetWorkspace(s string) {
	m.workspace = &s
}

// Workspace returns the workspace value in the mutation.
func (m *UserLevelMutation) Workspace() (r string, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkspace reset all changes of the workspace field.
func (m *UserLevelMutation) ResetWorkspace() {
	m.workspace = nil
}

// SetDeveloperID sets the developer edge to User by id.
func (m *UserLevelMutation) SetDeveloperID(id uint) {
	m.developer = &id
}

// ClearDeveloper clears the developer edge to User.
func (m *UserLevelMutation) ClearDeveloper() {
	m.cleareddeveloper = true
}

// DeveloperCleared returns if the edge developer was cleared.
func (m *UserLevelMutation) DeveloperCleared() bool {
	return m.cleareddeveloper
}

// DeveloperID returns the developer id in the mutation.
func (m *UserLevelMutation) DeveloperID() (id uint, exists bool) {
	if m.developer != nil {
		return *m.developer, true
	}
	return
}

// DeveloperIDs returns the developer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DeveloperID instead. It exists only for internal usage by the builders.
func (m *UserLevelMutation) DeveloperIDs() (ids []uint) {
	if id := m.developer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeveloper reset all changes of the developer edge.
func (m *UserLevelMutation) ResetDeveloper() {
	m.developer = nil
	m.cleareddeveloper = false
}

// SetLevelID sets the level edge to Level by id.
func (m *UserLevelMutation) SetLevelID(id uint) {
	m.level = &id
}

// ClearLevel clears the level edge to Level.
func (m *UserLevelMutation) ClearLevel() {
	m.clearedlevel = true
}

// LevelCleared returns if the edge level was cleared.
func (m *UserLevelMutation) LevelCleared() bool {
	return m.clearedlevel
}

// LevelID returns the level id in the mutation.
func (m *UserLevelMutation) LevelID() (id uint, exists bool) {
	if m.level != nil {
		return *m.level, true
	}
	return
}

// LevelIDs returns the level ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LevelID instead. It exists only for internal usage by the builders.
func (m *UserLevelMutation) LevelIDs() (ids []uint) {
	if id := m.level; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLevel reset all changes of the level edge.
func (m *UserLevelMutation) ResetLevel() {
	m.level = nil
	m.clearedlevel = false
}

// Op returns the operation name.
func (m *UserLevelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserLevel).
func (m *UserLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserLevelMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, userlevel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userlevel.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, userlevel.FieldCode)
	}
	if m.workspace != nil {
		fields = append(fields, userlevel.FieldWorkspace)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlevel.FieldCreatedAt:
		return m.CreatedAt()
	case userlevel.FieldUpdatedAt:
		return m.UpdatedAt()
	case userlevel.FieldCode:
		return m.Code()
	case userlevel.FieldWorkspace:
		return m.Workspace()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlevel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userlevel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userlevel.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case userlevel.FieldWorkspace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspace(v)
		return nil
	}
	return fmt.Errorf("unknown UserLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserLevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserLevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserLevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserLevelMutation) ResetField(name string) error {
	switch name {
	case userlevel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userlevel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userlevel.FieldCode:
		m.ResetCode()
		return nil
	case userlevel.FieldWorkspace:
		m.ResetWorkspace()
		return nil
	}
	return fmt.Errorf("unknown UserLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.developer != nil {
		edges = append(edges, userlevel.EdgeDeveloper)
	}
	if m.level != nil {
		edges = append(edges, userlevel.EdgeLevel)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userlevel.EdgeDeveloper:
		if id := m.developer; id != nil {
			return []ent.Value{*id}
		}
	case userlevel.EdgeLevel:
		if id := m.level; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserLevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeveloper {
		edges = append(edges, userlevel.EdgeDeveloper)
	}
	if m.clearedlevel {
		edges = append(edges, userlevel.EdgeLevel)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case userlevel.EdgeDeveloper:
		return m.cleareddeveloper
	case userlevel.EdgeLevel:
		return m.clearedlevel
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserLevelMutation) ClearEdge(name string) error {
	switch name {
	case userlevel.EdgeDeveloper:
		m.ClearDeveloper()
		return nil
	case userlevel.EdgeLevel:
		m.ClearLevel()
		return nil
	}
	return fmt.Errorf("unknown UserLevel unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserLevelMutation) ResetEdge(name string) error {
	switch name {
	case userlevel.EdgeDeveloper:
		m.ResetDeveloper()
		return nil
	case userlevel.EdgeLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown UserLevel edge %s", name)
}
